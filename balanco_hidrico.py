# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'pyqt_gui.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets

import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 6})
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

import numpy as np
import pandas as pd

import geopandas
import fiona
from shapely.geometry import Point
from shapely.ops import cascaded_union

from time import time

fiona.supported_drivers['KML'] = 'rw'

arquivo_bacias = "dados/bacias/Bacia_Hidrografica.shp"

dic_cod_bacia = {
    'gravataí': "dados/mini_bacias/G010_mini_19_02.shp",
    'sinos': "dados/mini_bacias/G020_mini_19_02.shp",
    'caí': "dados/mini_bacias/G030_mini_19_02.shp",
    'taquari-antas': "dados/mini_bacias/G040_mini_19_02.shp",
    'alto jacuí': "dados/mini_bacias/G050_mini_19_02.shp",
    'vacacaí-vacacaí-mirim': "dados/mini_bacias/G060_mini_19_02.shp",
    'baixo jacuí': "dados/mini_bacias/G070_mini_19_02.shp",
    'lago guaíba': "dados/mini_bacias/G080_mini_19_02.shp",
    'pardo': "dados/mini_bacias/G090_mini_19_02.shp",
    'tramandaí': "dados/mini_bacias/L010_mini_19_02.shp",
    'litoral médio': "dados/mini_bacias/L020_mini_19_02.shp",
    'camaquã': "dados/mini_bacias/L030_mini_19_02.shp",
    'mirim são gonçalo': "dados/mini_bacias/L040_mini_19_02.shp",
    'mampituba': "dados/mini_bacias/L050_mini_19_02.shp",
    'apuaê-inhandava': "dados/mini_bacias/U010_mini_19_02.shp",
    'passo fundo': "dados/mini_bacias/U020_min_19_02.shp",
    'turvo santa rosa santo cristo': "dados/mini_bacias/U030_mini_19_02.shp",
    'piratinim': "dados/mini_bacias/U040_mini_19_02.shp",
    'ibicuí': "dados/mini_bacias/U050_mini_19_02.shp",
    'quaraí': "dados/mini_bacias/U060_mini_19_02.shp",
    'santa maria': "dados/mini_bacias/U070_mini_19_02.shp",
    'negro': "dados/mini_bacias/U080_mini_19_02.shp",
    'ijuí': "dados/mini_bacias/U090_mini_19_02.shp",
    'várzea': "dados/mini_bacias/U100_mini_19_02.shp",
    'butuí-icamaquã': "dados/mini_bacias/U110_mini_19_02.shp",
}

def str_num_to_float(str_array):
    float_array = []
    for i in str_array:
        if i == '-':
            i = 0.
        else:
            i = str(i).replace(',', '.')
        float_array.append(float(i))
    return np.array(float_array)
    
def procurar_cadastros_siout(extrato, area):
    #processos do siout na area de drenagem
    print('Encontrando os processos do SIOUT que pertencem a área de drenagem...')
    t1 = time()

    xs = []
    ys = []
    ids = []
    for idx, row in extrato.iterrows():
        p = Point(row['Longitude'], row['Latitude'])
        if p.within(area[0]):
            xs.append(p.x)
            ys.append(p.y)
            ids.append(idx)

    t2 = time()
    delta_t = t2 - t1
    print('Isso levou {} segundos \n'.format(int(delta_t)))

    return xs, ys, ids
    
def remover_duplicatas(lista):
    s = []
    for i in lista:
        if i not in s:
            s.append(i)
    return s

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Balanço hídrico")
        Dialog.resize(650, 600)
        #Dialog.showMaximized()
        self.gridLayout_2 = QtWidgets.QGridLayout(Dialog)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.groupBox = QtWidgets.QGroupBox(Dialog)
        self.groupBox.setObjectName("groupBox")
        self.gridLayout = QtWidgets.QGridLayout(self.groupBox)
        self.gridLayout.setObjectName("gridLayout")
        self.latbox = QtWidgets.QDoubleSpinBox(self.groupBox)
        self.latbox.setMinimum(-500.0)
        self.latbox.setMaximum(500.0)
        self.latbox.setObjectName("latbox")
        self.gridLayout.addWidget(self.latbox, 0, 1, 1, 1)
        self.sel_extrato_btn = QtWidgets.QPushButton(self.groupBox)
        self.sel_extrato_btn.setObjectName("sel_extrato_btn")
        self.gridLayout.addWidget(self.sel_extrato_btn, 3, 0, 1, 2)
        self.label_2 = QtWidgets.QLabel(self.groupBox)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.longbox = QtWidgets.QDoubleSpinBox(self.groupBox)
        self.longbox.setMinimum(-500.0)
        self.longbox.setMaximum(500.0)
        self.longbox.setObjectName("longbox")
        self.gridLayout.addWidget(self.longbox, 1, 1, 1, 1)
        self.label = QtWidgets.QLabel(self.groupBox)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.salvar_shp_btn = QtWidgets.QPushButton(self.groupBox)
        self.salvar_shp_btn.setObjectName("salvar_shp_btn")
        self.gridLayout.addWidget(self.salvar_shp_btn, 5, 0, 1, 2)
        self.calcular_btn = QtWidgets.QPushButton(self.groupBox)
        self.calcular_btn.setObjectName("calcular_btn")
        self.gridLayout.addWidget(self.calcular_btn, 4, 0, 1, 2)
        self.vaz_sim = QtWidgets.QDoubleSpinBox(self.groupBox)
        self.vaz_sim.setObjectName("vaz_sim")
        self.gridLayout.addWidget(self.vaz_sim, 2, 1, 1, 1)
        self.label_3 = QtWidgets.QLabel(self.groupBox)
        self.label_3.setObjectName("label_3")
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.gridLayout_2.addWidget(self.groupBox, 0, 0, 1, 1)
       
        #widget 1
        self.mapa, self.axmapa = plt.subplots(figsize=(10,10))
        self.canvasmapa = FigureCanvas(self.mapa)
        self.widget = self.canvasmapa
        self.widget.setObjectName("widget")
        self.gridLayout_2.addWidget(self.widget, 0, 1, 1, 1)
        self.mtoolbar = NavigationToolbar(self.canvasmapa, self.widget)
        
        #widget 2
        self.balplot, self.axbalplots = plt.subplots(2, 1, figsize=(4,10))
        self.canvasbalplot = FigureCanvas(self.balplot)
        self.widget_2 = self.canvasbalplot
        self.widget_2.setObjectName("widget_2")
        self.gridLayout_2.addWidget(self.widget_2, 1, 0, 1, 2)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Balanço hídrico"))
        self.groupBox.setTitle(_translate("Dialog", "Insira os parâmetros"))
        self.label.setText(_translate("Dialog", "Latitude"))
        self.label_2.setText(_translate("Dialog", "Longitude"))
        self.sel_extrato_btn.setText(_translate("Dialog", "Selecione o extrato do SIOUT"))
        self.calcular_btn.setText(_translate("Dialog", "Calcular balanço hídirco"))
        self.salvar_shp_btn.setText(_translate("Dialog", "Slavar shape file"))
        self.label_3.setText(_translate("Dialog", "Vazão simulada (m³/s)"))
        
        #connecting buttons
        self.sel_extrato_btn.clicked.connect(self.carregar_extrato)
        self.calcular_btn.clicked.connect(self.calcular)
        self.salvar_shp_btn.clicked.connect(self.salvar_shp)
        
    def carregar_extrato(self):
        file_path = QtWidgets.QFileDialog.getOpenFileName(None, "Selecione o extrato do SIOUT", "", "CSV files (*.csv)")
        extrato_siout = file_path[0] 
        self.df_extrato_siout = pd.read_csv(extrato_siout, sep=';', encoding='unicode_escape', error_bad_lines=False)
        print('Transformando as colunas de string para float...')
        colunas= ['Latitude', 'Longitude', 'Vazão janeiro', 'Vazão fevereiro', 'Vazão março', 'Vazão abril', 'Vazão maio', 'Vazão junho', 'Vazão julho', 'Vazão agosto', 'Vazão setembro', 'Vazão outubro', 'Vazão novembro', 'Vazão dezembro']
        for c in colunas:
            self.df_extrato_siout[c] = str_num_to_float(self.df_extrato_siout[c].values)
        print('Extrato do SIOUT lido com sucesso!\n')
        print('ATENÇÃO: o programa não faz nenhuma filtragem no extrato do SIOUT. Todos os cadastros listados serão levados em consideração no balanço hídrico!\n')
    
    def salvar_shp(self):
        arquivo_kml = QtWidgets.QFileDialog.getSaveFileName(None, "Selecione onde o arquivo será salvo", "", "KML files (*.kml)")
        arquivo_kml_str = arquivo_kml[0]
        self.mini_bacias_uniao.to_file(arquivo_kml_str, driver='KML')
        print(arquivo_kml_str)
        
    def calcular(self):
        self.axmapa.cla()
        self.axbalplots[0].cla()
        self.axbalplots[1].cla()
        print('Calculando balanço hídrico...\n')

        print('Lendo arquivo das bacias hidrográficas...\n')
        bacias = geopandas.read_file(arquivo_bacias)
        #bacias = bacias.to_crs("EPSG:4674")

        print('Lendo coordenadas...')
        longitude =  self.latbox.value()
        latitude =  self.longbox.value()
        ponto_informado = Point((latitude, longitude))
        print('O ponto informado é: {}\n'.format(ponto_informado))

        print('Verificando a qual bacia o ponto informado petence...')
        pertence = False
        for idx, row in bacias.iterrows():
            if ponto_informado.within(row['geometry']):
                bacia = row['nome']
                bacia_idx = idx
                print('O ponto selcionado pertence a bacia {}\n'.format(bacia))
                pertence = True
                break

        if pertence == True:

            print('Lendo arquivo de mini bacias...')
            t1 = time()
            mini_bacias = geopandas.read_file(dic_cod_bacia[bacia.lower()])
            #mini_bacias = mini_bacias.to_crs("EPSG:4674")
            t2 = time()
            delta_t = t2 - t1
            print('Isso levou {} segundos \n'.format(int(delta_t)))
            

            print('Verificando a qual mini bacia o ponto informado petence...')
            t1 = time()
            for idx, row in mini_bacias.iterrows():
                if ponto_informado.within(row['geometry']):
                    mini_bacia = row['Mini']
                    mini_bacia_idxs = idx
                    print('O ponto selcionado pertence a mini bacia {}'.format(mini_bacia))
                    t2 = time()
                    delta_t = t2 - t1
                    print('Isso levou {} segundos \n'.format(int(delta_t)))
                    break

            print('Encontrando as mini bacias que pertencem a área de drenagem...')
            print('Há {} mini bacias.'.format(len(mini_bacias)))
            t1 = time()
            c = 1
            ad_c = [mini_bacia]

            minis = mini_bacias['Mini'].values
            minijus = mini_bacias['MiniJus']
            indices = mini_bacias.index.values
            filtro = np.zeros(len(minis))
            filtro[mini_bacia_idxs] = 1

            existe_bacia = True
            while existe_bacia == True:
                print('Iteração {} para {} mini bacias'.format(c, len(ad_c)))
                ad_p = []
                for mb in ad_c:
                    f = minijus == mb
                    filtro[f] = 1
                    ad_p = ad_p + minis[f].tolist()
                if len(ad_c) == 0:
                    existe_bacia = False
                else:
                    ad_c = remover_duplicatas(ad_p)
                    c = c + 1

                print('{} mini bacias fazem parte da área de drenagem.'.format(sum(filtro)))
                ad_idx = indices[np.where(filtro == 0, False, True)]
                t2 = time()
                delta_t = t2 - t1
                print('Isso levou {} segundos \n'.format(int(delta_t)))

            print('Aglutinando as minibacias...')
            t1 = time()
            polys = [mini_bacias.iloc[idx]['geometry'] for idx in ad_idx]
            self.mini_bacias_uniao = geopandas.GeoSeries(cascaded_union(polys))
            t2 = time()
            delta_t = t2 - t1
            print('Isso levou {} segundos \n'.format(int(delta_t)))


            xs, ys, ids = procurar_cadastros_siout(self.df_extrato_siout, self.mini_bacias_uniao)

            #Plotando os mapas
            print('Plotando...')

            bacias.loc[[bacia_idx], 'geometry'].plot(ax=self.axmapa, color='gainsboro', edgecolor='silver', alpha=1)
            self.mini_bacias_uniao.plot(ax=self.axmapa, color='gray', alpha=1)
            mini_bacias.loc[[mini_bacia_idxs], 'geometry'].plot(ax=self.axmapa, color='black', alpha=1)
            self.axmapa.scatter(ponto_informado.x, ponto_informado.y, label='Ponto informado', marker='x', s=15)
            if len(xs) > 0:
                self.axmapa.scatter(x=xs, y=ys, label='Cadastros SIOUT', s=15)
            
            self.axmapa.set_title('Bacia {}'.format(bacia))
            self.axmapa.set_ylabel('Latitude')
            self.axmapa.set_xlabel('Longitude')
            self.axmapa.legend()
            self.axmapa.grid()
            
            self.canvasmapa.draw_idle()
            self.mapa.tight_layout()

            #plotando o balanço hídrico
            vaz_simulada = self.vaz_sim.value()
            vaz_bacias = mini_bacias.loc[mini_bacia_idxs, ['Qref01', 'Qref02', 'Qref03', 'Qref04', 'Qref05', 'Qref06', 'Qref07', 'Qref08', 'Qref09', 'Qref10', 'Qref11', 'Qref12']].values
            vaz_siout = self.df_extrato_siout.loc[ids, ['Vazão janeiro', 'Vazão fevereiro', 'Vazão março', 'Vazão abril', 'Vazão maio', 'Vazão junho', 'Vazão julho', 'Vazão agosto', 'Vazão setembro', 'Vazão outubro', 'Vazão novembro', 'Vazão dezembro']]
            vaz_siout_mes = np.sum(vaz_siout, axis=0).values

            print('PROPRIEDADES:')
            perc_out =  mini_bacias.loc[mini_bacia_idxs, 'perc_out']
            print('Máximo outorgável: {}'.format(perc_out))
            vaz_max_out = vaz_bacias * perc_out
            bal_inicial = vaz_max_out - vaz_siout_mes
            bal_final = bal_inicial - vaz_simulada

            print('Vazão da bacia: {}'.format(vaz_bacias))
            print('Usos SIOUT: {}'.format(vaz_siout_mes))
            print('Balanço inicial: {}'.format(bal_inicial))
            print('Balanço final: {}'.format(bal_final))

            area_de_drenagem = mini_bacias.loc[mini_bacia_idxs, 'AreaDren']
            print('Área de drenagem: {}'.format(area_de_drenagem))
            #print('Vazão de referência: {}'.format('N/D'))

            tick_label = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez']

            cores = np.where(bal_inicial > 0, 'g', 'r')
            self.axbalplots[0].bar([x for x in range(1, 13)], bal_inicial, tick_label=tick_label, color=cores)
            for x,y in zip([x for x in range(1, 13)], bal_inicial):
                self.axbalplots[0].text(x-.25, y, str(round(y,4)))
            self.axbalplots[0].set_title('Balanço inicial')
            self.axbalplots[0].set_ylabel('Vazão m³/s')
            self.axbalplots[0].grid()
            cores = np.where(bal_final > 0, 'g', 'r')
            self.axbalplots[1].bar([x for x in range(1, 13)], bal_final, tick_label=tick_label, color=cores)
            for x,y in zip([x for x in range(1, 13)], bal_final):
                self.axbalplots[1].text(x-.25, y, str(round(y,4)))
            self.axbalplots[1].set_title('Balanço final')
            self.axbalplots[1].set_ylabel('Vazão m³/s')
            self.axbalplots[1].grid()

            self.balplot.tight_layout()
            
            self.df_extrato_siout.loc[ids].to_csv('extrato_filtrado.csv', index=False, sep=';')

        else:
            print('O ponto não pertence ao estado do RS.')

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())
